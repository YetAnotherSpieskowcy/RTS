\section{Widzenie przez horyzont (Bartosz Strzelecki)}\label{s:wid_impl}
Efekt został osiągnięty poprzez zmodyfikowanie potoku renderowania w taki sposób, że w zależności od wartości w buforze głębi jest wykorzystywany inny shader.
W tym przypadku, jeżeli sfera jest przysłonięta przez ścianę jest ona narysowana, w przeciwnym wypadku jest uruchamiany pusty shader.
"Unity domyślnie sortuje obiekty na podstawie odległości od kamery. Tak więc
w miarę zbliżania się obiektu do kamery, będzie on rysowany nad wszystkimi obiektami znajdującymi się dalej od kamery.
W większości przypadków sprawdza się to dobrze podczas tworzenia gier, ale
znajdą się sytuacje, w których będziemy chcieli mieć większą kontrolę nad sortowaniem obiektów na scenie. Używając bloku \verb|Tags\{\}| możemy kontrolować to sortowanie.
Unity udostępniło nam kilka domyślnych kolejek renderowania, z których każda ma unikalną wartość, którą
kieruje Unity, kiedy należy narysować obiekt na ekranie. Te wbudowane kolejki renderowania
nazywają się \verb|Background|, \verb|Geometry|, \verb|AlphaTest|, \verb|Transparent| i \verb|Overlay|." \cite{shaderscookbook}. Wykorzystując ten mechanizm
możliwe jest uzyskanie efektu widzenia przez postać gracza poprzez horyzont. Uzyskujemy przez to efekt podobny do tego zaimplementowanego w grze \textit{Dead by Daylight} (por. \ref{chap:dbd}).

Po naciśnięciu przycisku \texttt{E} następuje zagranie animacji opisanej wzorami

\begin{equation}
w(t, offset) = 1.1 \times 2.1^{-\left(\frac{{\left(\sin(t) + 1 - 0.4 - \text{{offset}}\right)^2}}{{0.02}}\right)}
\end{equation}

oraz

\begin{equation}
w(t, 0) - w(t, -0.2) + w(t, -1) - w(t, -1.2)
\end{equation}

Od podanych funkcji zależy przeźroczystość, jak i natężenie efektu Fresnela. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{images/g}
    \caption{Wykres przedstawiający funkcję opisującą natężenie efektu w animacji markera.}
\end{figure}



\begin{lstlisting}[language=C++, caption=Fragment shadera odpowiedzialny za animację.]
fixed4 frag (v2f i) : SV_Target
{
  float t =  6.2 * _Progress - 0.6;
  fixed4 pattern = tex2D(_PatternTex, i.uv + _Speed *t);
  float fresnelInfluence = dot(i.worldPos, i.viewDir);
  float saturatedFresnel = saturate(1 - fresnelInfluence);

  float g = w(t, 0) - w(t, -0.2) + w(t, -1) - w(t, -1.2);
  float4 color = pow(saturatedFresnel, g * _FresnelPow) * (_Color * _ColorIntensity) * pattern;
  color.a *= dot(i.worldPos, i.viewDir);
  return color;
}
\end{lstlisting}

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{images/shader}
\caption{Zachowanie programu cieniującego w przypadku przysłaniania markera przez przeszkody.}
\end{figure}
